자바 8 인액션 - 함수형 Data 처리

Chapter 4. 스트림 소개
	스트림이란 무엇인가?
	컬렉션과 스트림
	내부 반복과 외부 반복
	중간 연산과 최종연산

컬렉션은 자바에서 가장 많이 사용하는 기능중 하나다.

 	- 대부분 비즈니스 로직에는 요리를 카테고리(예를 들면 채식주의자용)로 그룹화 한다든가 
 	가장 비싼 요리를 찾는 등의 연산이 포함된다. 
 	대부분의 데이터베이스에서는 선언형으로 이와 같은 연산을 표현할 수 있다.
 	SELECT name FROM dishes WHERE calorie < 400
 	이라는 문장은 칼로리가 낮은 요리를 선택하라는 SQL 질의다.

 	SQL 질의에서 알 수 있듯이 요리의 속성을 이용하여 어떻게 필터링 할것인가 구현할 필요가 없다.
 	(예를 들어, 자바처럼 반복자, 누적자 등을 이용할 필요가 없다.)
 	SQL 언어에서는 우리가 기대하는 것이 무엇인지 직접 표현할 수 있다.

 	- 많은 요소를 포함하는 커다란 컬렉션은 어떻게 처리해야 할까?
 	성능을 높이려면 멀티코어 아키텍처를 활용해서 병렬로 컬렉션 요소를 처리해야 한다.
 	하지만 병렬처리 코드를 구현하는 것은 단순 반복 처리코드에 비해 복잡하고 어렵다.
 	게다가 복잡한 디버깅도 어렵다!!

 4.1 스트림이란 무엇인가?
 스트림은 자바 API 에 새로 추가된 기능으로, 스트림을 이용하면 선언형 
 (즉, 데이터를 처리하는 임시 구현 코드 대신 질의로 표현할 수 있다.) 으로 컬렋ㄴ 데이터를 처리할 수 잇다.

 또한 스트림을 이용하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

 	기존 코드 (java7)
 	List<Dish> lowCaloricDished = new ArrayList<>();
 	for(Dish d : menu) {
 		if (d.getCalories() < 400) {
 			lowCaloricDishes.add(d);
 		}
 	}

 	Collections.sort(lowCaloricDishes, new Comparator<Dish>()) {
 		public int compare(Dish d1, Dish d2) {
 			return Integer.compare(d1.getCalories(), d2.getCalories());
 		}
 	}
 	=> 익명 클래스로 요리를 전달

 	List<String> lowCaloricDishesName = new ArrayList<>();
 	for(Dish d : lowCaloricDishes) {
 		lowCaloricDishesName.add(d.getName());
 	}

 	위 코드에서는 lowCaloricDishes 라는 가비지 변수가 사용되었다.
 	즉, lowCaloricDishes 는 컨테이너 역할만 하는 중간 변수다.

 	최신 코드 (java8)

 	import static java.util.Comparator.comparing;
 	import static java.util.stream.Collections.toList;

 	List<String> lowCaloricDishesName = 
 				menu.stream()
 					.filter(d -> d.getCalories() < 400)
 					.sorted(comparing(Dish::getCalories))
 					.map(Dish::getName)
 					.collect(toList());

 	위에 코드를 보면 filter 를통해 정의를 하고
 	sorted 를 통해서 칼로리 요리 정렬을 하고
 	map 을 통해 요리명 추출을 하고 모든 요리명을 리스트로 저장한다.

 	위에 코드에서 menu.stream() 을 menu.parallelStream() 으로 바꾸면
 	병렬로 실행할 수 있다.

 parallelStream 을 호출했을때 정확히 어떤 일이 일어날까?
 얼마나 많은 쓰레드가 사용되는 걸까? 얼마나 성능이 좋아질까?
 7장에서 이 모든 질문의 답을 자세히 설명한다.

 스트림 API 는 매우 비싼 연산이다. 예를 들어 4,5,6 장을 학습하고 나면 다음과 같은 코드를 구현할 수 있다.

 Map <Dish.Type, List<Dish>> dishesByType = 
 		menu.stream().collect(groupingBy(Dish::getType));

 이 예제는 '스트림으로 데이터 수집' 에서 자세히 설명한다. 
 예를 들어 Map 은 다음과 같은 결과를 포함할 수 잇다.
 {
 	FISH = [parawns, salmon],
 	OTHER = [french fries, rice, season fruit, pizza],
 	MEAT = [pork, beef, chicken]
 }

 일반적인 명령형 프로그래밍의 루프를 이용한다면 이문제를 어떻게 해결했을지 생각해보라..

 API 의 특징
 	선언형 : 더 간결하고 가독성이 좋아진다.
 	조립할 수 있음 : 유연성이 좋아진다.
 	병렬성 : 성능이 좋아진다.

 4.2 스트림 시작하기
 	스트림 중 가장 간단한 작업에 해당하는 컬렉션 스트림
 	자바 8의 컬렉션에서는 스트림을 반환하는 stream 이라는 메서드가 추가되었다.

 	스트림이란 '데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소' 로 정의한다.

 	'연속된 요소'	: 
 	컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
 	컬렉션은 자료구조이므로 컬렉션에서는 시간과 공간이 복잡성과 관련된 요소 저장 및 접근이 주를 이룬다.
 	(ArrayList 를 사용할지, LinkedList 를 사용할지)

 	반면, 스트림은 filter, sorted, map 처럼 표현계산식이 주를 이룬다.

 	'소스' 	: 
 	스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.
 	정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다.
 	즉, 리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서를 유지한다.

 	'데이터 처리 연산' 	:
 	filter, map, reduce, find, match, sort 등 으로 데이터 조작 가능
 	스트림 연산은 순차적 또는 병렬로 실행할 수 있다.

 	'파이프 라이닝' 	:
 	대부분 스트림 연산은 스트림끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림을 반환한다.
 	그덕분에 게으름(laziness), 쇼트서킷(short-circuting) 같은 최적화도 얻을수 있다.

 	|내부 반복|
 	자바8인액션 134p ~ 135p 보기 (그림이 너무 많음)

 4.3 스트림과 컬렉션
 	스트림과 컬렉션의 차이를 시각적으로 살펴보자면
 	컬렉션 은 DVD 비디오를 생각하면 어느 여기에서는 모든 프레임이 load 저장되어 잇다.
 	그런데 요즘에는 스트리밍이 나오기 시작했다. 스트리밍은 데이터의 일부만 미리 받아 놓고 필요할 떄 사용한다.
 	만약 데이터를 한번에 다 받아와서 재생을 할려면 매우 시간이 오래걸릴 것이다.

 	즉, 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이라고 할 수 있다.

 	컬렉션은 현재 자료구조가 '포함하는 모든값' 을 메모리에 저장하는 자료구조다.
 	즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산 되어야 한다.

 	결과적으로 스트림은 게으르게 만들어지는 컬렉션과 같다.
 	즉, 사용자가 데이터를 요청할 때만 값을 계산한다.

 4.3.1 딱 한번만 탐색할 수 있다!
 	반복자와 마찬가지로 스트림도 한번만 탐색할 수 있다.
 	즉, 탐색된 스트림의 요소는 소비된다. 반복자와 마찬가지로 한번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.

 	List<String> flieName = Arrays.asList("java8", "In", "Action");
 	Stream<String> s = flieName.stream();

 	s.forEach(System.out::println) <- 요소들이 출력된다.
 	s.forEach(System.out::println) <- java.lang.IllegalStateException: 스트림이 이미 소비되었거나 닫힘

 	스트림은 단 한번만 소비할 수 있다!

 4.3.2 외부반복과 내부반복
 	컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다. ex) for-each 이를 외부반복이라하고
	스트림 라이브러리는 내부반복을 사용할 수 있다.

	스트림 내부 반복
	List<String> names = menu.stream()
							 .map(Dish::getName)
							 .collect(toList());
 4.4 스트림 연산
 4.4.1 중간 연산
 	filter 나 sorted 같은 중간 연산은 다른 스트림을 반환한다.
 	따라서 여러 중간 연산을 연결해서 질의를 만들 수 있다.
 	lazy 한 연산을 하기 때문에 여러개의 요소가 있겠지만 원하는 만큼만 선택된다.

 	limit 연산 -> 쇼트서킷 기법
 	filter, map 은 서로 다른 연산이지만 한 과정으로 병합되었다. -> 루프 퓨전

 4.4.2 최종 연산

 4.4.3 스트림 이용하기
 	스트림 이용 과정은 다음과 같이 세가지로 요약할 수 있다.

 	질의를 수행할 (컬렉션 같은) '데이터 소스'
 	스트림 파이프라인을 구성할 '중간 연산' 연결
 	스트림 파이프라인을 실행하고 결과를 만들 '최종 연산'

 	스트림 파이프라인의 개념은 빌더패턴고 ㅏ비슷하다.
 4.5 요약
 	스트림은 소스에서 추출된 연속요소로, 데이터 처리 연산을 지원한다.
 	스트림은 내부 반복을 지원한다. 내부반복은 filter, map, sorted 등의 연산으로 반복을 추상화 한다.
 	스트림에는 중간 연산과, 최종연산이 있다.
 	중간연산으로는 어떠한 결과로 생성할 수 없다.

Chapter 5. 스트림 활용
	4장에서는 스트림을 이용해서 외부 반복을 내부 반복으로 바꾸는 방법을 살펴보았다.
	이장의 내용 :
	♢ 필터링, 슬라이싱 매칭
	♢ 검색, 매칭, 리듀싱
	♢ 특정 범위의 숫자와 같은 숫자 스트림 사용하기
	♢ 다중 소스로부터 스트림 만들기
	♢ 무한 스트림

 4장에서는 스트림 이용해서 외부반복을 내부반복으로 바꾸는 방법을 살펴봤다.
 데이터를 어떻게 처리할지는 스트림 API 가 관리하므로 편리하게 데이터 관련 작업을 할 수 있다.

 따라서 스트림 API 내부적으로 다양한 최적화가 이루어질 수 있다.
 스트림 API 는 내부반복 뿐 아니라 코드를 병렬로 실행할지 여부도 결정할 수 있다.

 이장에서는 스트림 API 가 지원하는 다양한 연산을 살펴본다.
 스트림 API 가 지원하는 다양한 연산을 살펴본다. 
 스트림 API 가 지원하는 연산을 이용해서 필터링, 슬라이싱, 검색, 매칭 리듀싱 등 다양한 데이터 처리 질의를 표현할 수 있다.
 다음으로 숫자 스트림, 파일과 배열 등 다양한 소스로 스트림을 만드는 방법, 무한 스트림 등 특수한 경우도 살펴본다.

 5.1 필터링과 슬라이싱
 이 절에서는 스트림 요소를 선택하는 방법, 즉 프레디케이트 필터링, 고유 요소 필터링, 
 스트림의 일부 요소를 무시하거나 스트림을 주어진 크기로 축소하는 방법을 설명한다.

 5.1.1 프레디케이트로 필터링
 스트림 인터페이스는 filter 메서드를 지원한다(이젠 이 메서드에 익숙할 것이다.)
 filter 메서드는 프레디케이트 를 인수로 받아서 프레디 케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다.

 예를들어, 모든 채식요리를 필터링 해서 채식 메뉴를 만들 수 있다.

 List<Dish> vegetarianMenu = menu.stream()
 								 .filter(Dish::isVegetarian)
 								 .collect(toList());

 5.1.2 고유 요소 필터링
 distinct() 	-> 중복 제거 필터링

 5.1.3 스트림 축소
 limit(n)	

 5.1.4 요소 건너뛰기
 skip(n)

 스트림은 처음  n 개 요소를 제외한 스트림을 반환하는 skip(n) 메서드를 지원한다.
 limit(n) 과 skip(n) 은 상호보완적인 연산을 수행한다.

 예를들어 다음 코드는 300cal 이상의 처음 두요리를 건너뛴 다음에 300킬로가 넘는 나머지 요리를 반환한다. 

 List<Dish> dishes = menu.stream()
 					 	 .filter -> d.getCalories() > 300)
						 .skip(2)
						 .collect.toList());

5.2 맵핑
특정 객체에서 특정 데이터를 선택하는 작업은 데이터 처리과정에서 자주 수행되는 연산이다.
예를들어 SQL 의 테이블에서 특정 열만 선택할 수 있다. 
스트림 API 의 map 과 flatMap 메서드는 특정 데이터를 선택하는 기능을 제공한다.

5.2.1 스트림의 각 요소에 함수 적용하기.
	이제 요리명의 길이를 반환하는 함수를 만들라면 어떻게 하면 될까?

	List<String> dishNames = menu.stream()
								 .map(Dish::getName)
								 .collect(toList());

	이렇게 하면 각 음식의 이름을 뽑아낼수 있을것이다.

	이제는 

	List<Integer> dishNameLengths = menu.stream()
										.map(Dish::getName)
										.map(String::length)
										.collect(toList());

	이렇게 하면 각 음식의 이름길이를 나타낼수 잇다.

5.2.2 스트림 평면화
	메서드 map 을 이용해서 리스트의 각 단어의 길이를 반환하는 방법을 확인햇다.
	이를 응용해서 리스트에서 고유문자로 이루어진 리스트를 반환해보자. 
	예를 들어 ["Hello", "World"] 리스트가 잇다면
	["H", "e", "l", "o", "W", "r", "d"] 를 포함하는 리스트가 반환되어야 한다.

	words.stream()
		 .map(word -> word.split(""))
		 .distinct()
		 .collect(toList());
	[그림 5-5] 를 보면 문제점을 알 수 있다. <- 제대로 원하는 결과를 얻을수 없다.


	위 코드에서 map 으로 전달한 람다는 각 단어의 String[] 을 반환한다는 점이 문제다.
	map 메서드가 반환하는 스트림의 형식은 Stream<String[]> 이다.
	우리가 원하는 것은 문자열의 스트림을 표현할 Stream<String> 이다.

	다행히 flatMap 이라는 메서드를 이용해서 이문제를 해결할 수 있다.

	map과 Arrays.stream 활용

	우선 배열 스트림 대신 문자열 스트림이 필요하다. 
	Arrays.stream() 메서드가 있다.

	String[] arrayOfWrods = {"Goodbye", "World"};
	Stream<String> streamOfwords = Arrays.stream(arrayOfWrods);

	flatMap 사용

	List<String> uniqueCharacters = 
		words.stream()
			 .map(w -> w.split(""))
			 .flatMap(Arrays::stream)
			 .distinct()
			 .collect(Collectors.toList());

	flatMap 은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 맵핑한다.
	즉, map(Arrays::stream) 과 달리 flatMap 은 하나의 평면화된 스트림을 반환한다.

	요약하면 flatMap 메서드는 스트림의 각 값을 다른 스트림으로 만든 
	다음에 모든 스트림을 하나의 스트림으로 연결 하는 기능을 수행한다.

	10장에서는 null 을 확인하는 새로운 라이브러리 클래스인 Optional 이라는 고급 자바 8 패턴을 설명하면서 
	flatMap 을 다시 설명한다.

	[퀴즈 5-2]
	1. 숫자 리스트가 주어졌을 때 각 수자의 제곱근으로 이루어진 리스트를 반환하시오. 예를 들어
	[1,2,3,4,5] 가 주어지면 [1,4,9,16,25] 를 반환해야 한다.

	2. 두개의 숫자 리스트가 있을 때 모든 숫자 쌍의 리스트를 반환하시오. 
	[1,2,3] 과 [3,4] 가 주어지면
	[(1,3), (1,4), (2,3), (2,4), (3,3), (3,4)] 를 반환해야 한다.

	3. 이전 예제에서 합이 3으로 나누어 떨어지는 쌍만 반환하려면 어떻게 해야 할까? 예를 들어 (2,4), (3,3)
	[정답 5-2]
	1. 
	List<Integer> square(List<Integer> origin) {
			return origin.stream()
						 .map(n -> n * n)
						 .collect(toList())
		}

	2.
	List<int[]> makePairs(List<Integer> number1, List<Integer> number2) {
		List<int[]> pairs = number1.stream()
									.flatMap(i -> number2.stream()
														.map(j -> new int[]{i, j})
											 )
									.collect(toList());

		return pairs;
	}

	3. 
	List<int[]> makePairs(List<Integer> number1, List<Integer> number2) {
		List<int[]> pairs = number1.stream()
									.flatMap(i -> number2.stream()
														.filter(j -> (i+j)%3 == 0)
														.map(j -> new int[]{i, j})
											 )
									.collect(toList());

		return pairs;
	}
 

5.3 검색과 매칭 
	 특정 송성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리도 자주 사용된다.
	 스트림 API 는 allMatch, anyMatch, noneMatch, findFirst, findAny 등 다양한 유틸리티 메서드를 제공한다.

5.3.1 프레디케이트가 적어도 한 요소와 일치하는지 확인.
	 if (menu.stream().anyMatch(Dish::isVegetarian)) {
	 	System.out.println("The menu is (somewhat) vegetarian friendly!!");
	 }

	anyMatch 는 boolean 을 반환하므로 최종 연산이다.

5.3.2
	 allMatch 는 anyMatch 와 달리 스트림의 모든 요소가 주어진 프레디케이트와 일치하는지 검사한다.

	 noneMatch 는 allMatch 와 반대연산을 수행한다. 즉, 일치하는 요소가 없는지 확인한다.

	 allMatch, noneMatch, anyMatch 는 스트림 쇼트서킷 기법, 즉 자바의 &&, || 와 같은 연산을 활용한다.

	 '소트서킷 평가'
	 때로는 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있다. 
	 예를 들어 and 연산으로 연결된 커다란 불린표현식을 평가한다고 하면 표현식에서 하나라도 거짓이라는 결과가 나오면
	 나머지 표현식의 결과와 상관없이 전체 결고도 거짓이 된다. 이러한 상황을 쇼트서킷이라고 부른다.

	 limit 도 쇼트서킷 연산이다. 


5.3.3 요소 검색
	findAny 메서드는 현재 스트림에서 임의의 요소를 반환한다. findAny 메서드를 다른 스트림 연산과 연결해서 사용할 수 있다.
	예를 들어, filter, findAny 를 이용해서 채식 요리를 선택할 수 있다.

		Optional<Dish> dish = 
				menu
				.stream()
				.filter(Dish::isVegetarian)
				.findAny();

	스트림 파이프 라인은 내부적으로 단일 과정으로 실행할 수 있도록 최적화 된다. 즉 쇼트서킷을 이용해서 결과를 찾는 즉시 실행을 종료한다.

	'Optional' 이란?

	Optional<T> 클래스 는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스다.
	이전 예제에서 findAny 는 아무요소도 반환하지 않을 수 있다. null 은 쉽게 에러를 일으킬 수 있으므로

	일단 Optional 은 값이 존재하는지 확인하고, 값이 없을때 어떻게 처리할 것인지 강제하는 기능을 제공한다는 사실만 알아두자.

	isPresent() 는 Optional 이 값을 포함하면 true, 포함하지 않으면 false 를 반환한다.

	ifPresent(Comsumer<T> block) 은 값이 잇으면 주어진 블록을 실행한다. Consumer 함수형 인터페이스 3장에서 설명했다.

	T get() 값이 존재하면 반환하고 없으면 NoSuchElementException 을 일으킨다.
	T orElse(T other) 는 값이 있으면 반환하고 없으면 기본값을 반환하다.

	예를 들어 Optional<Dish> 는 값이 있으면 반환하고 없으면 기본값을 반환한다.

	menu.stream()
		.filter(Dish::isVegetarian)
		.findAny()	<- Optional<Dish>
		.isPresent(d -> System.out.println(d.getName()));   <- 값이 잇으면 출력되고, 없으면 아무일도 일어나지 않는다.

5.3.4 첫번째 요소 찾기
	.findFirst

5.4 리듀싱
	지금까지 살펴본 최종 연산은 boolean(allMatch 등), void (forEach), 또는 Optional 객체(findAny) 를 반환했다.
	또한 collect 로 모든 스트림의 요소를 리스트로 모으는 방법도 살펴 봣다.

	이절에서는 리듀스(reduce) 연산을 이용해서 '메뉴의 모든 칼로리의 합계를 구하시오', '메뉴에서 칼로리가 가장 높은 요리는?'
	같이 스트림 요소를 조합해서 더 복잡한 질의를 표현하는 방법을 설명한다.

5.4.1 요소의 합
	reduce 를 살펴보기 전에 우선 for-each 루프를 이용해서 각 숫자요소를 더하는 코드를 만들자.

	int sum = 0;
	for (int x : numbrers) {
		sum += x;
	}

	int sum = numbrers.stream().reduce(0, (a, b) -> a + b);

	reduce 는 2개의 인수를 갖는다.
	초기값 0 
	두 요소를 조합해서 새로운 값을 만드는 BinaryOperator<T> 
	예제에서는 람다 표현식 (a, b) -> a + b 를 사용함.

	메서드 레퍼런스를 이용해서 좀더 간결하게 만들 수 있다.

	int sum = numbrers.stream().reduce(0, Integer::sum;

	'초기값 없음' 초기값을 받지 않도록 된 reduce 도 있다. 
	그러나 이 reduce 는 Optional 객체를 반환한다.
	그 이유는, 스트림에는 아무요소도 없는 상황이 있을수 있으므로, reduce 합계를 반환할수 없게되므로
	Optional 로 감싼 결과를 반환한다.


5.4.2 최댓값과 최솟값

	Optional<Integer> max = numbrers.stream().reduce(Integer::max);
	Optional<Integer> min = numbrers.stream().reduce(Integer::min);

	Integer::min 대신 (x, y) -> x<? x:y 를 써도 무방하지만 레퍼런스표현이 더 읽기 쉽다.

	[퀴즈 5-3]

	map 과 reduce 를 이용해서 스트림 요리 갯수를 계산하시오

	int count = menu.stream()
					.map(d -> 1)
					.reduce(0, Integer::sum);

	map 과 reduce 를 연결하는 기법을 맵리듀스 패턴이라 하며, 쉽게 병렬화 하는 특징 덕분에
	구글이 웹 검색에 적용하면서 유명해 졌다. 4장에서는 count 로 스트림 요소 수를 세는 방법을 살펴봤다.

	long count = menu.stream().count();

	'reduce 메서드의 장점과 병렬화'

	reduce를 이용하면 내부반복이 추상화 되면서 내부 구현에서 병렬로 reduce 를 실행할 수 있게 된다.
	반복적인 합계에서는 sum 변수를 공유하므로 쉽게 병렬화 하기 어렵다.

	강제적으로 동기화 시킨다 하더라도 결국 병렬호로 얻어야 할 이득이 스레드 간의 소모적인 경쟁때문에 상쇄되어 버린다는 사실을 알게 될것이다.
	사실 이 작업을 병렬화 하려면 입력을 분할하고, 분할된 입력을 더한 다음에 더한 값을 합쳐야 한다.

	7장에서는 포크/조인 프레임워크를 이용하는 방법을 살펴본다. 

	7장에서는 스트림의 모든 요소를 더하는 코드를 병렬로 만드는 방법도 설명한다. 
	stream() -> parallelStream() 으로 바꾸면 된다.

	int sum = numbrers.parallelStream().reduce(0, Integer::sum);

	나중에 자세히 설명하겠지만, 위의 코드를 실행하려면 대가를 지불행 한다.
	즉, reduce 에 넘겨준 람다의 상태(instance 변수) 변하지 않아야 하며, 연산이 어떤 순서로 실행되더라도 결과가 바뀌지 말아야 한다.

	책갈피 : 165p 지금까지 정수 / 17.12.12

5.5 실전 연습
	이 절에서는 지금까지 배운 스트림을 실제 사용한다.

	1. 2011년에 일어난 모든 트랜잭션을 찾아 값을 오름차순으로 정리하시오.
	2. 거래자가 근무하는 모든 도시를 중복없이 나열하시오.
	3. 케입브리지에서 근무하는 모든 거래자를 찾아서 이름순으로 정렬하시오.
	4. 모든 거래자의 이름을 알파벳순으로 정렬해서 반환하시오.
	5. 밀라노 에 거래자가 있는가?
	6. 케임브리지에 거주하는 거래자의 모든 트랜잭션값을 출력하시오.
	7. 전체 트랜잭션 중 최댓값은 얼마인가?
	8. 전체 트랜잭션 중 최솟값은 얼마인가?
	

	[실전 문제 자료] - 다음과 같은 거래자(Trader) 와 트랜잭션(Transaction) 리스트를 이용한다.

	Trader raoul = new Trader("Raoul", "Cambridge");
	Trader mario = new Trader("Mario", "Milan");
	Trader alan = new Trader("Alan", "Cambridge");
	Trader brian = new Trader("brian", "Cambridge");

	List<Transaction> transaction = Arrays.asList(
		new Transaction(brian, 2011, 300),
		new Transaction(raoul, 2012, 1000),
		new Transaction(raoul, 2011, 400),
		new Transaction(mario, 2012, 710),
		new Transaction(alan, 2012, 950)
		);


	[실전 문제 정답]

	1. 2011년에 일어난 모든 트랜잭션을 찾아 값을 오름차순으로 정리하시오.
	transaction.stream()
				.filter(transaction -> transaction.getYear == 2011)
				.sorted(comparing(Transaction::getValue))
				.collect(toList());

	2. 거래자가 근무하는 모든 도시를 중복없이 나열하시오.
	transaction.stream()
				.map(transaction -> transaction.getTrader().getCity())
				.distinct()
				.collect(toList()); -> [distinct 대신에 toSet 을 이용할 수도 있다.]

	3. 케입브리지에서 근무하는 모든 거래자를 찾아서 이름순으로 정렬하시오.
	transaction.stream()
				.map(Transaction::getTrader)
				.filter(trader -> trader.getCity().equals("Cambridge"))
				.distinct()
				.sorted(comparing(Trader::getName))
				.collect(toList());

	4. 모든 거래자의 이름을 알파벳순으로 정렬해서 반환하시오.
	transaction.stream()
				.map(transaction -> transaction.getTrader().getName())
				.distinct()
				.sorted()		: 이름을 알파벳 순으로 정렬
				.reduce("", (n1, n2) -> n1 + n2); : 각각의 이름을 하나의 문자로 연결하여 결국 모든 이름연결

	5. 밀라노 에 거래자가 있는가?
	transaction.stream()
				.anyMatch(transaction -> transaction.getTrader().getCity().equals("Milan"));
	6. 케임브리지에 거주하는 거래자의 모든 트랜잭션값을 출력하시오.
	transaction.stream()
				.filter(t -> "Cambridge".equals(t.getTrader().getCity))
				.map(Transaction::getValue)
				.forEach(System.out::println);
	7. 전체 트랜잭션 중 최댓값은 얼마인가?
	transaction.stream()
				.reduce((t1, t2) -> t1.getValue < t2.getValue ? t1 : t2);
	8. 전체 트랜잭션 중 최솟값은 얼마인가?
	transaction.stream()
				.min(comparing(Transaction::getValue));


5.6 숫자형 스트림
5.6.1 기본형 특화 스트림
	자바 8 에서는 3가지 기본형 특화 스트림을 제공한다.
	int 요소에 특화된 IntStream
	double 요소에 특화된 DoubleStream
	long 요소에 특화된 LongStream

	각각의 인터페이스는 숫자 스트림의 합계를 계산할 수 있는 sum, 
	최대값 요소를 검색하는 max 같이 자주 사용하는 숫자 관련 리듀싱 연산을 제공한다.
	또한 필요할때 다시 스트림으로 복원하는 기능도 제공한다.

	
	숫자 스트림으로 매핑
	int calories = menu.stream()
						.mapToInt(Dish::getCalories)
						.sum();
	이 외에도 mapToDouble, mapToLong 들이 있다.

	객체 스트림 복원하기.

	IntStream IntStream = menu.stream().mapToInt(Dish::getCalories);
	Stream<Integer> stream = IntStream.boxed(); <- 숫자 스트림을 스트림으로 변환.

	기본값 OptionalInt
	합계 예제에서 0이라는 기본값이 있었으므로 별 문제가 없었다.
	하지만 IntStream 에서 최댓값을 찾을때 0이라는 기본값 때문에 이게 실제 최댓값 0 인지 기본값인지 구분할 수가 없다.

	이전에 값이 존재하는지 여부를 가리킬수 있는 컨테이너 클래스 Optional 이 있었다.
	예를들어 다음처럼 OptionalInt 를 이용해서 IntStream 의 최댓값 요소를 찾을수 있다.

	OptionalInt maxCalories = menu.stream()
								.mapToInt(Dish::getCalories)
								.max();
	int max = maxCalories.orElse(1); <- 값이 없을때 기본 최댓값을 명시적으로 설정.

5.6.2 숫자 범위
	IntStream evenNumbers = IntStream.rangeClosed(1, 100)
									.filter(n -> n%2 == 0); <- 1~100까지의 짝수 스트림


	rangeClosed 는 1,100 을 포함하고
	range 는 1, 100 을 포함하지 않는다.

5.6.3 숫자 스트림 활용 : 피타고라스 정의
5.7 스트림 만들기 / 178p 18.01.12
5.7.1 값으로 스트림 만들기
임의의 수를 인수로 받는 정적 메소드를 Stream.of 를 이용해서 스트림을 만들 수 있다.
예를 들어 다음 코드는 Stream.of 로 문자열 스트림을 만드는 예제다. 스트림의 모든 문자열을 대문자로 변환한후 문자열을 하나씩 출력한다.

Stream<String> string = Stream.of("Java8", "Lambdas", "In", "Action");
stream.map(String::toUpperCase).forEach(System.out::println);
다음처럼 empty 메서드를 이용해서 스트림을 비울수 있다.

Stream<String> emptyStream = Stream.empty();

5.7.2 배열로 스트림 만들기.
int[] numbers = {2, 3, 5, 7, 11, 13};
int sum = Arrays.stream(numbers).sum(); <- 합계 = 41

5.7.3 파일로 스트림 만들기
파일을 처리하는 등의 I/O 연산에 사용하는 자바의 NIO API(비블록 I/O)도 스트림 API 를 활용할 수 있도록 업데이트 되었다.
다음 코드를 사용하면 파일에서 고유한 단어 수를 찾는 프로그램을 만들수 있다.
long uniqueWords = 0;
try (Stream<String> lines = 
		Files.lines(Paths.get("data.txt"), Charset.defaultCharset())) {
	uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(" ")))
						.distinct()
						.count();
} catch (IOException e) {

}

line 에서 split 을 통해 각 단어를 분리하고 flatMap 을 통해 평면화 했다.
그리고나서 distinct 와 count를 연결해서 스트림의 고유 단어수를 계산한다.

5.7.4 함수로 무한 스트림 만들기

스트림 API 는 함수에서 스트림을 만들수 있는 두개의 정적 메서드 Stream.iterate 와 Stream.generate 를 제공한다.
두연산을 이용한 무한 스트림(infinite stream, 즉 고정된 컬렉션에서 고정된 크기의 스트림을 만들었던것과는달리 , 고정되지 않은 스트림을 만들수있다.)

iterate, generate 에서 스트림은 요청할 떄마다 주어진 함수를 이용해서 값을 만든다.
보통 무제한은 출력하지 않으니 limit(n) 함수를 함께 사용한다.

Stream.iterate(new int[]{0, 1}, t -> new int[] {t[1], t[0] + t[1]})
			.limit(10)
			.map(t -> t[0])
			.forEach(System.out::println);

generate
generate 는 iterate 와 달리 값을 연속적으로 계산하지 않는다.
Stream.generate(Math::random)
	.limit(5)
	.forEach(System.out::println);


5.8 요약 
컬렉션을 더 효율적으로 처리하게 한다.

filter, distinct, skip, limit 메서드로 스트림을 필터링 하거나 자를수 있다.

map, flatMap 메서드로 스트림의 요소를 추출하거나 변환할 수 있다.

findFirst, findAny, allMatch, anyMatch , noneMatch 를 이용해
주어진 프레디케이트와 일치하는 요소를 스트림에서 검색할 수있다. 이들은 쇼트서킷을 이용한다.

reduce 메서드로 스트림의 모든 요소를 반복 조합하며 값을 도출할 수 있다. 
예를 들어 reduce 로 최댓값이나 최솟값을, 합계를 계산 할 수 있다.

filter, map 등은 상태를 저장하지 않는 상태 없는 연산이다.
reduce 는 값을 계산하는데 필요한 상태를 저장한다.
sorted, distinct 등의 메서드는 스트림을 반환하기 위해 앞서 스트림의 모든 요소를 버퍼에 저장한다.
이런 메서드를 상태 있는 연산이라 한다.

IntStream, LongStream, DoubleStream 기본형 특화 스트림
iterate, generate 와 같은 메서드로도 스트림을 만들 수 있다.

Chapter 6. 스트림으로 데이터 수집
4장과 5장에서는 스트림에서 최종 연산 collect 를 사용하는 방법을 확인했다.
4, 5 장에서는 toList 로 스트림 요소를 항상 리스트로만 변환했다.

이장에서는 reduct 가 그랬던 것처럼 collect 역시 다양한 요소 누적 방식을 인수로 받아서 스트림을 최종 결과로 도출하는 리듀싱 연산을 수행할 수 있음을 설명한다.
지금부터 Collection, Collector, collect 를 헷갈리지 않도록 주의하자.

collect, 컬렉터로 구현할 수 있는 질의 예제다.

ex) 통호별로 트랜잭션을 그룹화한 코드 
Map<Currency, List<Transaction>> transactionsByCurrencies = 
					transactions.stream().collect(groupingBy(Transaction::getCurrency));
간단하게 한줄이면 끝난다.

6.1 컬렉터란 무엇인가?
함수형 프로그래밍에서는 필요한 컬렉터를 쉽게 추가할 수 있다.

6.1.1 고급 리듀싱 기능을 수행하는 컬렉터
훌륭하게 t설계된 함수형 API 의 또다른 장점으로 높은 수준의 조합성과 재사용성을 꼽을수 있다.
collect 로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 컬렉터의 최대 강점이다.
수체적으로 설명하면 스트림에 collect 를 호출하면 스트림에 요소에 리듀싱 연산이 수행된다.

Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩토리 메서드를 제공한다.
예를 들어 가장 많이 사용하는 직관적인 정적메서드로 toList 를 꼽을 수 있다. toList 는 스트림의 모든 요소를 리스트로 수집한다.

6.1.2 미리 정의된 컬렉터
6장에서는 미리정의된 컬렉터 , 즉 groupingBy 같이 Collectors 클래스에서 제공하는 팩토리 메서드의 기능을 설명한다.

Collectors 에서 제공하는 메서드의 기능은 크게 3가지로 구분할 수 있다.
	- 스트림 요소를 하나의 값으로 리듀스하고 요약 -> 리듀싱과 요약
	- 요소 그룹화
	- 요소 분할

6.2 리듀싱과 요약 
컬렉터로 스트림의 항목을 컬렉션으로 재구성할 수 있다. 좀더 일반적으로 말해 컬렉터로 만든 스트림의 모든 항목을 하나의 결과로 합칠수 있다.
트리를 구성하는 다수준 맵, 메뉴의 칼로리 합계를 가리키는 단순한 정수 등 다양한 식으로 나타낼 수 있다.

예제 1. counting() 이라는 팩토리 메서드가 반환하는 컬렉터로 메뉴에서 요리수를 계산한다.

long howManyDishes = menu.stream().collect(Collectors.counting());

다음처럼 불필요한 과정을 생략할 수 있다.
long howManyDishes = menu.stream().count();

counting 컬렉터는 다른 컬렉터와 함께 사용할 때 위력을 발휘한다.

6.2.1 스트림 값에서 최댓값과 최솟값  검색
메뉴에서 칼로리가 가장 높은 요리를 찾는다고 가정하자.
Collectors.maxBy, Collectors.minBy 를 이용해서 계산할 수 있다.

Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);
Optional<Dish> mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));

Optional<Dish> 는 무슨 역할을 수행하는 것일까?

스트림에 있는 객체의 숫자 필드의 합계나 평균등을 반환하는 연산에도 리듀싱 기능이 자주 사용된다. 이러한 연산을 요약연산이라 부른다.

6.2.2 요약연산
Collectors 클래스는 Collectors.summiingInt 라는 특별한 요약 메서드를 제공한다.
summiingInt 는 객체를 int 로 매핑하는 함수를 인수로 받는다. 

다음은 메뉴 리스트의 총 칼로리를 계산하는 코드다.

int totalCalories = menu.stream().collect(summiingInt(Dish::getCalories));

Collectors.summingLong 과 Collectors.summingDouble 도 summiingInt 와 같은 방식으로 동작한다.

이러한 연산은 다양한 연산도 요약연산으로 제공한다. 즉 averagingInt, 등도 있다.

6.2.3 문자열 연결
컬렉터에 joining 팩토리 메서드를 이용하면 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 만들어준다.

즉, 다음은 메뉴의 모든 요리명을 연결하는 코드다.

String shortMenu = menu.stream().map(Dish::getName).collect(joining());

joining 메서드는 내부적으로 StringBuilder 를 이용해서 문자열을 하나로 만든다.
Dish 클래스가 요리명을 반환하는 toString 메서드를 포함하고 있따면 다음 코드에서 보여주는 것처럼 map 으로 각 요리의 이름을 추출하는 과정을 생략할 수 있다.

String shortMenu = menu.stream().collect(joining());

위 두 코드는 모두 다음과 같은 결과를 도출한다.
porkbeefchickenfrench friesriceseason ~~~
하지만 이것은 해석할 수가 없다.

그래서 중간에 구분 문자를 넣을수 있도록 오버로드된 joining 팩토리 메서드가 있다.
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
위의 코드를 실행시키면
pork, beef, chicken, french fries, rice, season ~~~ 처럼 출력이 될것이다.

6.2.4 범용 리듀싱 요약 연산
지금까지 살펴본 모든 컬렉터는 reducing 팩토리 메서드로도 정의할 수 있다. 즉, 범용 Collectors.reducing 으로도 구현할 수 있다.

그럼에도 불구하고 범용 리듀싱 대신에 특화된 컬렉터를 사용한 이유는 편의성때문이다. 하지만 가독성도 좋아진다.

int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i,j) -> i + j));

reducing 은 3개의 인수를 받는다.
첫번째 인수는 리듀싱 연산의 시작값이나, 스트림 에 인수가 없을때 반환값이다.(숫자의 합에서 인수가 없을때 0 을 반환하는 것이 적합하다)
두번째 인수는 6.2.2 절에 요리를 칼로리 정수로 변환할 떄 사용한 변환함수다. 
세번째 인수는 같은 종류의 두 항복을 하나의 값으로 더하는 BinaryOperator 다 . 예제에서는 2개의 int 가 사용되었다.

다음처럼 1개의 인수를 가진 reducing 버전을 이용해서 가장 칼로리가 높은 요리를 찾는 방법도 잇다.

OptionalInt<Dish> mostCalorieDish = 
			menu.stream().collect(reducing(
				(d1, d2) -> d1.getCalories() > d2.getCalories ? d1 : d2));

한개의 인수를 갖는 reducing 팩터리 메서드는 세개의 인수를 갖는 reducing 메서드에서 스트림 첫번째 요소를 시작요소, 
즉 첫번째 인수로 받으며, 자신을 그대로 반환하는 항등함수를 두번째 인수로 받는 상황에 해당한다.

즉, 한개의 인수를 갖는 reducing 컬렉터는 시작값이 없으므로 빈 스트림이 넘겨졌을때 시작값이 설정되지 않는 상황이 벌어진다.

'컬렉션 프레임워크 유연성 : 같은 연산도 다양한 방식으로 수행할 수 잇다.'

reducing 컬렉터를 사용한 이전 예제에서 람다 표현식 대신에 Integer 클래스의 sum 메서드 레퍼런스를 이용하면 
코드를 좀더 단순화할 수 있다. 다음코드를 확인하자.

int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, Integer::sum));

counting 컬렉터도 3개의 인수를 갖는 reducing 팩토리 메서드를 이용해서 구현할 수 있다.


6.3 그룹화
데이터 집합을 하나 이상의 특성으로 분류해서 급후화하는 연산도 데이터베이스에서 많이 수행되는 작업이다.
트랜잭션 통화 그룹화 예제에서 확인했듯이 명령형으로 그룹화를 구현하려면 까다롭고, 할일이 많으며 에러도 많이 발생한다.


이번에는 메뉴를 그룹화한다고 가정하자. 
예를 들어 고기를 포함하는 그룹, 생선을 포함하는 그룹, 나머지를 그룹화 할 수 있다.
다음처럼 패곹리 메서드 Collectors.groupingBy 를 이용해서 쉽게 메뉴를 그룹화할 수 있다.

Map<Dish, Type, List<Dish>> dishesType = 
				menu.stream().collect(groupingBy(Dish::getType));

다음은 Map 에 포함된 결과다.

{FISH=[parawns, salmon], OTHER=[french fries, rice, season fruit, pizza],
MEAT=[pork, beef, chicken]}


더 복잡한 분류 기준이 필요한 상황에서는 메서드 레퍼런스를 분류함수로 사용할 수 없다.
예를 들어 
400 칼로리 이하를 'diet' 
400~700 칼로리를 'normal'
700 칼로리 초과를 'fat'

로 분류한다고 가정하자.

이러한 연산에 필요한 메서드가 없으므로 메서드 레퍼런스를 분류 함수로 사용할 수 없다.
따라서 다음예제에서 보여주는 것처럼 메서드레퍼런스 대신 람다 표현식으로 필요한 로직을 구현할 수 있다.

public enum CaloricLevel { DIET, NORMAL, FAT}

Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream().collect(
		groupingBy(dish -> {
			if (dish.getCalories() <= 400) {
				return CaloricLevel.DIET;
			} else if (dish.getCalories() <= 700) {
				return CaloricLevel.NORMAL;
			} else {
				return CaloricLevel.FAT
			}
		}));


지금까지 메뉴의 요리를 종류 또는 칼로리로 그룹화하는 방법을 살펴봤다.
그러면 요리 종류와 칼로리 두 가지 기준으로 동시에 그룹화할 수 있을까?
그룹화의 진정한 능력은 지금부터 발휘된다. 다음 내용을 살펴보자.


6.3.1 다수준 그룹화
예제 6.2
	Map<Dish, Type, Map<CaloricLevel, List<Dish>>> dishesByCaloricLevel = 
		menu.stream().collect(
			groupingBy(Dish::getType, 
				groupingBy(dish -> {
					if (dish.getCalories() <= 400) {
						return CaloricLevel.DIET;
					} else if (dish.getCalories() <= 700) {
						return CaloricLevel.NORMAL;
					} else {
						return CaloricLevel.FAT;
					}
				})
			)
		);


	그룹화의 결과로 다음과 같은 두 수준의 맵이 만들어 진다.
	{MEAT = {DIET=[chicken], NORMAL=[beef], FAT=pork}
	 FISH = {DIET=[parawns], NORMAL=[salmon]},
	 OTHER = {DIET=[rice, season fruit], NORMAL=[french fries, pizza]}}

외부 맵은 첫번째 수준의 분류 합수에서 분류한 키 값 'fish, meat, other' 를 갖는다.
그리고 외부 맵의 값은 두번째 수준의 분류 함수의 기준 'normal, diet, fat' 을 키값으로 갖는다.

최종적으로 두 수준의 맵은 첫 번째 키와 두번째 키의 기준에 부합하는 요소 리스트 값(salmon, pizza 등) 으로 갖는다.


보통 groupingBy 의 연산을 '버킷' 개념으로 생각하면 쉽다.
첫번째 groupingBy 는 각 키의 버킷을 만든다. 그리고 준비된 각각의 버킷을 서브 스트림 컬렉션으로 채워간다.


6.3.2 서브그룹으로 데이터 수집

6.3.1 에서는 두번째 groupingBy 컬렉터를 외부 컬렉터로 전달해서 다수준 그룹화 연산을 구현했다.
사실 첫 번째 groupingBy 로 넘겨주는 컬렉터의 형식은 제한이 없다. 예를 들어 다음 코드처럼
groupingBy 컬렉터에 두번 째 인수로 counting 컬렉터를 전달해서 메뉴에서 요리의 수를 종류별로 계산할 수 있다.

Map<Dish.Type, Long> typesCount = menu.stream().collect(
				groupingBy(Dish::getType, counting()));

다음과 같은 결과 맵이다.

{MEAT=3, FISH=2, OTHER=4}

분류 함수 한개의 인수를 갖는 groupingBy(f) 는 사실 groupingBy(f, toList()) 의 축약형이다.

컬렉터 결과를 다른 형식에 적용하기.
마지막 그룹화 연산에서 맵의 모든 값을 OptionalInt 로 감쌀 필요가 없으므로 OptionalInt 을 삭제할 수 있다.
즉, 다음처럼 팩토리 메서드 Collectors.collectingAndThen 으로 컬렉터가 반환한 결과를 다른형식으로 활용할 수 잇다.

Map<Dish.Type, Dish> mostCalorieDishType = 
	menu.stream()
		.collect(groupingBy(Dish::getType, 
					collectingAndThen(
						maxBy(comparingInt(Dish::getCalories)),
						Optional::get)));

팩토리 멕서드 collectingAndThen 은 적용할 컬렉터와 변환 함수를 인수로 받아 다른 컬렉터를 반환한다.
반환되는 컬렉터는 기존 컬렉터의 래퍼 역할을 하며 collect 의 마지막 과정에서 변환 함수로 자신이 반환하는 값을 매핑한다.

groupingBy 와 함께 사용하는 다른 컬렉터 예제
(205p)

6.4 분할
분할은 분할함수(partitioning function) 라 불리는 프레디케이트를 분류함수로 사용하는 특수한 그룹화 기능이다.
분할 함수는 불린을 반환하므로 맵의 키 형식은 boolean 이다. 결과적으로 그룹화 맵은 최대 2개의 그룹으로 분류된다.

요리를 채식 요리와 아닌 요리로 분류하는 방법

Map<boolean, List<Dis>> partitionedMenu = 
		menu.stream().collect(partitioningBy(Dish::isVegetarian));

위 코드를 실행하면

{false=[pork, beef, chicken, parawns, salmon],
 true = [french fries, rice, season fruit, pizza]}

 가 반환된다.

 이제 참값의 키로 맵에서 모든 채식요리를 얻을 수 있다.

 List<Dish> vegetarianDishes = partitionedMenu.get(true);

 물론 메뉴 리스트로 생성한 스트림을 필터로도 거를수 있다.

 List<Dish> vegetarianDishes = menu.stream()
 									.filter(Dish::isVegetarian).collect(toList());


6.4.1 분할의 장점

분할 함수가 반환하는 참,거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점이다.

또한 다음 코드에서 보여주는 것처럼 컬렉터를 두번째 인수로 전달할 수 있는 오버로드 된 버전의
partitioningBy 메서드도 있다.

Map<boolean, Map<Dish.Type, List<Dish>>> vegetarianDishes = 
	menu.stream().collect(
		partitioningBy(Dish::isVegetarian,
						groupingBy(Dish::getType)));

다음의 위 코드를 실행 두 수준의 맵 결과다.

{
	false = {FISH=[parawns, salmon], MEAT=[pork, beef, chicken]},
	true = {OTHER=[french fries, rice, season fruit, pizza]}
}	

결과에서 확인할 수 있는 것처럼 채식 요리의 스트림 과 채식이 아닌 요리의 스트림을 각각 요리 종류로 그룹화 할 수 있다.

6.4.2 숫자를 소수와 비소수로 분할하기.

public boolean isPrime(int candidate) {
	return IntStream.range(2, candidate)
					.noneMatch(i -> candidate % i == 0);
}

public boolean isPrime(int candidate) {
	int candidateRoot = (int) Math.sqrt((double) candidate);
	return IntStream.rangeClosed(2, candidateRoot)
					.noneMatch(i -> candidate % i == 0);
}


6.5 Collector 인터페이스

Collector 인터페이스를 살펴보기 전에 6장을 시작하면서 살펴본 팩토리 메서드인 toList 를 자세히 확인하자 toList 는 앞에서 자주 사용하는 컬렉터중 하나이다.
동시에 toList 는 가장 구현하기 쉬운 컬렉터이기도 하다.

예제 6-4 Collector 인터페이스
public interface Collector<T, A, R> {
	Supplier<A> supplier();
	BiConsumer<A, T> accumulator();
	Function<A, R> finisher();
	BinaryOperator<A> combiner();
	Set<Characteristics> characteristics();
}

위의 코드는
T : 수집될 스트림 항목의 제네릭 형식이다.
A : 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식이다.
R : 수집 연산 결과 객체의 형식(항상 그런거는 아닌) 이다.

예를 들어 Stream<T> 의 모든 요소를 List<T> 로 수집하는 ToListCollector<T> 라는 클래스를 구현할 수 있다.

example : 'public class ToListCollector<T> implements Collector<T, List<T>, List<T>>'


6.5.1 Collector 인터페이스의 메서드 살펴보기.

supplier 메서드 : 새로운 결과 컨테이너 만들기

supplier 메서드는 빈 결과로 이루어진 Supplier 를 반환해야 한다. 즉, supplier 는 수집과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수다.
ToListCollector 처럼 누적자를 반환하는 컬렉터에서는 빈 누적자가 비어있는 스트림의 수집 과정의 결과가 될 수 있다.

ToListCollector 에서 supplier 는 다음처럼 빈 리스트를 반환한다.

	public Supplier<List<T>> supplier() {
		return () -> new ArrayList<T>();
	}

	생성자 레퍼런스를 전달하는 방법도 있다.

	public Supplier<List<T>> supplier() {
		return ArrayList::new;
	}

accumulator 메서드 : 결과 컨테이너에 요소 추가하기.

accumulator 메서드는 미듀싱 연산을 수행하는 함수를 반환한다. 스트림에서 n 번쨰 요소를 탐색 할 떄 두 인수, 
즉 누적자 (스트림의 첫 n-1 개 항목을 수집한 상태) 와 n 번째 요소를 함수에 적용한다.

함수의 반환값은 void, 즉 요소를 탐색하면서 적용하는 함수에 의해 누적자 내부 상태가 바뀌므로 누적자가 어떤 값을 단정할 수 없다.

ToListCollector 에서 accumulator 가 반환하는 함수는 이미 탐색한 항목을 포함하는 리스트에 현재 항목을 추가하는 연산을 수행한다.

	public BiConsumer<List<T>. T> accumulator() {
		return (list, item) -> list.add(item);
	}

	메서드 레퍼런스를 사용할 수도 있다.

	public BiConsumer<List<T>, T> accumulator() {
		return List::add;
	}


finisher 메서드 : 최종 변환값을 결과 컨테이너로 적용하기.

finisher 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼때 호출할 함수를 반환해야 한다.
때로는 ToListCollector 에서 볼 수 있는 것처럼 누적자 객체가 이미 최종결과인 상황도 있다.
이런때는 변환과정이 필요하지 않으므로 finisher 메서드는 항등 함수를 반환한다.

	public Function<List<T>, List<T>> finisher() {
		return Function.identity();
	}

실제로는 collect 가 동작하기 전에 다른 중간 연산과 파이프 라인을 구성할 수 있게 해주는 게으른 특성 그리고 병렬 실행등도 고려해야 하므로
스트림 리듀싱 기능 구현은 생각보다 복잡하다.

combiner 메서드 : 두 결과 컨테이너 병합

마지막으로 리듀싱 연산에서 사용할 함수를 반환하는 네번째 메서드 combiner 를 살펴본다.
combiner 는 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의한다.

toList 의 combiner 는 비교적 쉽게 구현할 수 있다. 즉, 스트림의 두번쨰 서브파트에서 수집한 항목 리스트를 첫번째 서브파트 결과 리스트 뒤에 추가하면 된다.


Characteristics 메서드
마지막으로 characteristics 메서드는 컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환한다.
Characteristics 는 스트림을 병렬로 리듀스 할 것인지 그리고 병렬로 리듀스 한다면 어떤 최적화를 선택해야 할지 힌트를 제공한다.

Characteristics 는 다음 세항목을 포함하는 열거형이다

'UNORDERED'
 - 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않는다.

 'CONCURRENT'
 - 다중 스레드에서 accumulator 함수를 동시에 호출할 수 있으며, 이 컬렉터는 스트림의 병렬 리듀싱을 수행할 수 있다.
 컬렉터의 플래그에 UNORDERED 를 함께 설정하지 않았따면 데이터 소스가 정렬되어 있지 않은 상황에서만 병렬 리듀싱을 수행할 수 있다.

 'INDENTITY_FINISH'
 finisher 메서드가 반환하는 함수는 단순히 identity 를 적용할 뿐 이므로 이를 생략할 수 있다. 따라서 리듀싱 과정의 최종 결과로 누적자 객체를 바로 사용할 수 있다.
 또한 누적자 A 를 결과 R 로 안전하게 형변환 할 수 있다.

 6.5.2 응용하기

 지금가지 살펴본 다섯가지 메서드를 이용해서 자신만의 커스텀 ToListCollector 를 구현할 수 있다.

 컬렉터 구현을 만들지 않고도 커스텀 수집 수행하기

 INDENTITY_FINISH 수집 연산에서는 Collector 인터페이스를 완전히 새로 구현하지 않고도 같은 결과를 얻을 수 있다.
 Stream 은 세함수 (supplier, accumulator, combiner) 를 인수로 받는 collect 메서드를 오버로드하며 
 각각의 메서드는 Collector 인터페이스의 메서드가 반환하는 함수와 같은 기능을 수행한다.

 예를 들어 다음처럼 스트림의 모든 항목을 리스트에 수집하는 방법도 있다.

 List<Dish> dishes = menuStream.collect(
 				ArrayList::new,
 				List::add,
 				List::addAll);

 위 두번째 코드가 이전 코드에 비해 좀더 간결하고 축약되어 있지만 가독성은 떨어진다.  (216p 참조)  '커스텀 컬렉터 만들기'
 적절한 클래스로 커스텀 컬렉터를 구현하는 편이 중복을 피하고 재사용성을 높이는데 도움이 된다.





6.6 커스텀 컬렉터를 구현해서 성능 개선하기.
 6.4 절에서 분할을 설명하면서 Collector 클래스가 제공하는 다양한 팩토리 메서드 중 하나를 이용해서 커스텀컬렉터를 만들었다.

public boolean isPrime(int candidate) {
	int candidateRoot = (int) Math.sqrt((double) candidate);
	return IntStream.rangeClosed(2, candidateRoot)
					.noneMatch(i -> candidateRoot % i == 0);
}

성능을 더 개선할 수 있을까? 커스텀 컬렉터를 이용하면 가능하다.

6.6.1 소수로만 나누기
	중간 결과 리스트가 있다면 isPrime 메서드로 중간 결과 리스트를 전달하도록 다음과 같이 코드를 수정할 수 있다.

	public static boolean isPrime(List<Integer> primes, int candidate) {
		return primes.stream().noneMatch(i -> candidate % i == 0);
	}

public static <A> List<A> takeWhile(List<A> list, Predicate<A> p) {
	int i = 0;
	for (A item : list) {
		if (!p.test(item)) {
			return list.subList(0, i);  		<- 리스트의 현재 요소가 프레디케이트를 만족하는지 검사한다.
		}
		i++;			<- 프레디케이트를 만족하지 않으면 검사한 항목 앞쪽에 위치한 서브리스트를 반환한다.
	}
	return list;	<- 리스트의 모든 항목이 프레디케이트를 만족하므로 리스트 자체를 반환한다.
}





커스텀 컬렉터를 만들고 싶다면 6장에 219p 를 참조하도록 하자.


Chapter 7. 병렬 데이터 처리와 성능
	- 병렬 스트림으로 데이터를 병렬 처리하기
	- 병렬 스트림의 성능 분석
	- 포크/조인 프레임 워크
	- Spliterator 로 스트림 데이터 쪼개기

4~6장에서는 새로운 인터페이스를 이용해서 데이터 컬렉션을 선언형으로 제어하는 방법을 살펴봤다.
또한 외부반복을 내부반복으로 바꾸면 네이티브 자바라이브러리가 스트림 요소의 처리를 제어할 수 있음을 확인했다.


자바 7은 더 쉽게 병렬화를 수행하면서 에러를 최소화 할 수 있도록 포크/조인 프레임워크 라는 기능을 제공한다.
포크/조인 프레임워크는 7.2 절에서 나온다.

스트림을 이용하면 순차스트림을 병렬 스트림으로 자연스럽게 바꿀수 있다.

우선 여러 청그를 병렬로 처리하기 전에 병렬 스트림이 요소를 여러 청크로 분할하는 방법을 설명할 것이다.
이 원리를 이해하지 못하며 ㄴ의도치 않은, 설명하기 어려운 결과가 발생할 수 있다.

7.1 병렬 스트림

스트림 인터페이스를 이용하면 아주 간단하게 병렬로 처리할 수 있다.
컬렉션에 parallelStream 을 호출하면 병렬 스트림이 생성된다. 병렬 스트림이 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.

따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 잇다.

숫자 n 을 인수로 받아서 1 ~ n 까지 모든 숫자의 합계를 반환하는 메서드를 구현한다고 가정하자.

	public static long sequentialSum(long n) {
		return Stream.iterate(1L, i -> i + 1)	<- 무한 자연수 스트림 생성
					.limit(n)
					.reduce(0L, Long::sum); 
	}

n 이 커질수록 병렬로 처리하는것이 좋은 것이다.

7.1.1 순차 스트림을 병렬 스트림으로 변환하기 
순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리된다.

	public static long sequentialSum(long n) {
		return Stream.iterate(1L, i -> i + 1)	
					.limit(n)
					.parallel()
					.reduce(0L, Long::sum); 
	}

위 코드에서는 모든 숫자를 더한다. 이전 코드와 다른점은
스트림이 여러 청크로 분할되어 있다는 것이다. 

parallel, sequential 이 있다. 각각 병렬, 순차 를 제어 하는 flag 역할을 하며 마지막에 쓰여진것을 따른다.

		'병렬 스트림에서 사용하는 스레드 풀 설정'
	병렬 스트림은 내부적으로 ForkJoinPool 을 사용한다.
	기본적으로 ForkJoinPool 은 프로세서 수, 즉 Runtime.getRuntime().availableProcessors() 가 반환하는 값에 상응하는 스레드를 갖는다.


7.1.2 스트림 성능 측정
병렬화를 이용하면 순차나 반복 형식에 비해 성능이 더 좋아질 것이라 추측했다. 하지만 소프으웨어 공학에서 추측은 위험한 방법이다.

고전적인 for 루프를 사용한 반복 버전이 생각보다 빠르다는 점도 고려해야 한다.
for 루프는 저수준으로 작동하며 기본값을 박싱하거나 언 박싱할 필요가 없으므로 수행 속도가 빠르다.

실제로 위에서 만든 n 까지의 합을 측정을 해보면 for 문을 사용했을때가 가장 빠르다.
이유는 아래와 같다.
	
	병렬이 더 느린 이유
	- iterate 가 박싱된 객체를 생성하므로 이를 다시 언박싱하는 과정이 필요했다.
	- iterate 는 병렬로 실행될 수 있도록 독립적인 청크로 분할하기가 어렵다.

	리듀싱 과정을 시작하는 시점에 전체 숫자 리스트가 준비되지 않았으므로(iterate) 스트림을 병렬로 처리할 수 있도록 분할할수가 없다.
	그러므로 병렬과 거리가 먼 iterate 를 사용하면 오히려 전체 프로그램의 성능이 더 나빠질 수도 있다.

※'parallel 메서드를 호출했을대 내부적으로 어떤 일이 일어나는지 꼭 이해해야 한다.'

더 특화된 메서드 사용
멀티 코어 프로세서를 활용해서 효과적으로 합계 연산을 병렬로 실행하려면 어떻게 해야 할까?

LongStream.rangeClosed 는 기본형 long 을 직접 사용하므로 박싱/언박싱 오버헤드가 사라진다.
LongStream.rangeClosed 는 쉽게 청크로 분할 할 수 있는 숫자 범위를 생산한다.
예를 들어 1-20 범위를 각각 1-5, 6-10, 11-15, 16-20 범위의 숫자로 분할할 수 있다.

	public static long parallelRangedSum(long n) {
		return LongStream.rangeClosed(1, n)
						.parallel()
						.reduce(0L, Long::sum);
	}

하면 빨라진다.

이처럼 올바른 자료구조를 선택해야 병렬실행도 최적의 성능을 발휘할 수 있다는 사실을 확인할 수 있다.
병렬화를 이용하려면 스트림을 재귀적으로 분할해야 하고, 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당하고 이들 결과를 하나의 값으로 합쳐야 한다.
멀티 코어 간의 데이터 이동은 우리 생각보다 비싸다, 따라서 코어간에 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코어에서 수행하는것이 바람직하다.

또한 상황에 따라 쉽게 병렬화를 이용할 수 있거나 아니면 아예 병려화를 이용할 수 없는 때도 있다. 
그리고 스트림을 병렬화해서 코드 실행속도를 빠르게 하고 싶으면 항상 병렬화를 올바르게 사용하고 있는지 확인해야 한다.
병렬화와 관련해서 흔히 일어나는 실수를 살펴보도록 하자.

7.1.3 병렬 스트림의 올바른 사용법.

병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용하기 때문이다.
다음은 n 까지의 자연수를 더하면서 공유된 누적자를 바꾸를 프로그램을 구현한 코드다.

	public static long sideEffectSum(long n) {
		Accumulator accumulator = new Accumulator();
		LongStream.rangeClosed(1, n).forEach(accumulator::add);
		return accumulator.total;
	}

	public class Accumulator {
		public long total = 0;
		public void add(long value) {
			total += value;
		}
	}

명령행 프로그래밍 패러다임에 익숙한 개발자라면 위와 같은 코드를 자주 구현할 것이다. 리스트의 숫자를 반복할 떄의 코드와 비슷하다.
즉, 누적자를 초기화하고 리스트의 각 요소를 하나씩 탐색하면서 누적자에 숫자를 추가할 수 있다.

코드에 문제가 되는점은.
본질적으로 순차실행할 수 있도록 구현되어 있으므로 병렬로 실행하면 참사가 일어난다. 특히 total 을 접근할 때마다 데이터 레이스 문제가 일어난다.
동기화로 문제를 해결하다 보면 결국 병렬화라는 특성이 없어져 버릴 것이다.

여러 스레드 에서 동시 누적자, 즉 total += value 를 실행하면 이런 문제가 발생한다
얼핏 보면 아토믹 연산 같지만 total += value 는 아토믹 연산이 아니다. 결국 여러 스레드에서 공유하는 객체의 상태를 바꾸는
forEach 블록 내부에서 add 메서드를 호출하면서 이와 같은 문제가 발생한다.

7.1.4 병렬 스트림 효과적으로 사용하기
	- 순차 스트림을 병렬 스트림으로 바꾼다고 항상 빠른것은 아니다. 모르겠으면 직접 성능을 측정하는것이 바람직하다.                                              
	- 박싱을 주의하라, 기본형 특화스트림을 사용하는 것이 좋다. (IntStream, LongStream, DoubleStream)
	- 순차스트림보다 병렬스트림에서 성능이 떨어지는 연산이 있다. 특히 limit, findFirst 처럼 요소의 순서에 의존하는 연산을 병렬스트림에서 수행하려면 비싼 비용을 치른다.
	- 처리해야할 요소가 N , 하나의 요소를 처리하는데 비용이 Q 이면 N*Q 의 시간이 드는데 Q 가 높아진다는 것은 병렬스트림으로 개선이 가능하다.
	- 소량의 데이터에서는 병렬스트림이 도움되지 않는다.
	- 스트림을 구성하는 자룍조가 적절한지 확인하라 
		(ArrayList 를 LinkedList 보다 효율적으로 분할할 수 있다. )
	- 필터 처리를 하면 스트림의 길이를 예측할 수 없으므로 효과적으로 스트림을 병렬처리할수 있을지 알 수 없게 된다.
	- 최종 연산의 병합 과정 (Collector, combiner 메서드) 비용을 살펴보라, 
		병합 과정의 비용이 비싸다면 병렬스트림으로 얻은 성능의 이익이 서브스트림의 부분결과를 합치는 과정에서 상쇄될 수 있다.

	소스가 				분해성
	ArrayList			훌륭함
	LinkedList			나쁨
	IntStream.range 	훌륭함
	Stream.iterate		나쁨
	HashSet				좋음
	TreeSet				좋음


7.2 포크/조인 프레임 워크
포크/조인 프레임워크는 병렬화 할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다.

7.2.1 Recursive Task 활용
스레드 풀을 이용하려면 Recursive<R> 의 서브클래스를 만들어야 한다.
여기서 R 은 병렬화된 태스크가 생성하는 결과형식 또는 결과가 없을때 는 RecursiveAction 형식이다. RecursiveTask 를 정의하려면 추상 메서드 compute 를 구현해야 한다.

compute 태스크를 서브태스크로 분할하는 로직과 더이상 분할 할수 없을때 개별 서브태스크의 결과를 생산할 알고리즘을 정의한다.

대부분의 compute 메서드 구현은 다음과 같은 의사코드 형식을 유지한다.

if (태스크가 충분히 작거나 더이상 분할할 수 없으면) {
	순차적으로 태스크 계산
} else {
	태스크를 두 서브 태스크로 분할
	태스크가 다시 서브태스크로 분할하도록 이 메서드를 재귀적으로 호출
	모든 서브 태스크의 연산이 완료될떄 까지 기다림
	각 서브 태스크의 결과를 합침
}

이 알고리즘은 분할 후 정복 알고리즘의 병렬화 버전이다. 


'포크/조인 프레임워크를 이용해서 병렬 합계 수행'

	public class ForkJoinSumCalculator extends java.util.concurrnt.RecursiveTask<Long> {

		private final long[] numbers;
		private final int start;
		private final int end;
		private static final long THRESHOLD = 10_000;	// 이 값 이하의 서브태스크는 더이상 분할할 수 없다.

		// 메인 태스크를 생성할 떄 사용할 공개 생성자
		public ForkJoinSumCalculator(long[] numbers) {
			this(numbers, 0, numbers.length);
		}

		// 메인 태스크의 서브 태스크를 재귀적으로 사용할 비공개 생성자
		private ForkJoinSumCalculator(long[] numbers, int start, int end) {
			this.numbers = numbers;
			this.start = start;
			this.end = end;


			@Override
			protected Long compute() {
				int length = end - start; 	// 이태스크에서 더할 배열의 길이
				if (length <= THRESHOLD) {
					return computeSequentially();
				}

				// 배열의 첫번째 절반을 더하도록 서브태스크를 생성한다.
				ForkJoinSumCalculator leftTask = 
					new ForkJoinSumCalculator(numbers, start, start + length / 2);
				// ForkJoinPool 의 다른 스레드로 새로 생성한 태스크를 비동기로 실행한다.
				leftTask.fork();

				// 배열의 나머지 절반을 더하도록 서브태스크를 생선한다.
				ForkJoinSumCalculator rightTask = 
					new ForkJoinSumCalculator(numbers, start + length / 2, end);

				// 두번째 서브태스크를 동기 실행한다. 이때 추가로 분할이 일어날 수 있다.
				Long rightResult = rightTask.compute();
				// 첫번째 서브태스크의 결과를 읽거나 아직 결과가 없으면 기다린다.
				Long leftResult = leftTask.join();
				// 두 서브태스크의 결과를 조합한 값이 이 태스크의 결과다.
				return leftResult + rightResult;
			}

			private long computeSequentially() {
				long sum = 0;
				for (int i = start; i < end; i++) {
					sum += numbers[i];
				}
				return sum;
			}
		}
	}

위 메서드는 n 까지의 자연수 덧셈 작업을 병렬로 수행하는 방법을 더 직관적으로 보여준다.

	public static long forkJoinSum(long n) {
		long[] numbers = LongStream.rangeClosed(1, n).toArray();
		ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);
		return new ForkJoinPool().invoke(task);
	}

를 하면 실행되어 진다. ForkJoinPool 의 invoke 메서드로 전달했다.


위의 결과를 실행하면 41 mileSeconds 가 나온다. 
이는 병렬 스트림을 사용할 떄보다 성능이 나빠졌지만 ForkJoinSumCalculator 태스크에서 사용할 수 있도록 전체 스트림을 long[] 으로 변환했기 때문이다.

7.2.2 포크/조인 프레임워크 제대로 사용하는 방법
	- join 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 떄 까지 호출자를 블록시킨다.
	따라서 두 서브태스크가 모두 시작된 다음에 join 을 호출해야 한다. 그렇지 않으면 각각의 서브 태스크가 다른 태스크 가 끝나기를 기다리며 성능이 악화된다.

	- RecursiveTask 내에서는 ForkJoinPool 의 invoke 메서드를 사용하지 말아야 한다.
	대신 compute 나 fork 메서드를 직접 호출 할 수 잇다. 순차 코드에서 병렬 계산을 시작할 때만 invoke 를 사용한다.

	- 서브태스크에서 fork 메서드를 호출해서 ForkJoinPool 의 일정을 조절할 수 있다. 
	왼쪽 작업과 오른쪽 작업 모두에 fork 메서드를 호출하는 것이 자연스러울 것 같지만, 한쪽 작업에는 fork 를 호출하는 것보다는
	compute 를 호추하는 것이 효율적이다. 그러면 두 서브태스크의 한 태스크에는 같은 스레드를 재사용할 수 있으므로 풀에서 불필요한 태스크를 할당하는 오버헤드를 피할수 있다.

	- 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어렵다.
	보통 IDE 로 디버깅할 때 스택 트레이스로 문제가 일어난 과정을 쉽게 확인할 수 있는데, 포크/조인 프레임워크에서는 
	fork 라 불리는 다른스레드에서 compute 를 호출하므로 스택트레이스가 도움이 되지 않는다.

	- 병렬 스트림에서 확인해본것처럼 멀티코어에 포크/조인 프레임워크를 사용하는것이 순차처리 보다 무조건 빠를거라는 생각은 버려야한다.
	각 서브태스크의 실행시간은 새로운 태스크를 포킹하는데 드는 시간보다 길어야 한다. 

	예를 들어 I/O 를 한 서브태스크에 서 할당하고 다른 서브태스크에서는 계산을 실행, 즉 I/O 와 계산을 병렬로 실행할 수 있다.
	또한 순차 버전과 병렬버전의 성능을 비교할 때는 다른 요소도 고려해야 한다. 

	또한 컴파일러 최적화는 병렬 버전보다 순차버전에 집중될 수 있다는 사실도 기억하자.


7.2.3 작업 훔치기.
	CPU 를 유효상태로 돌리지 않고, 실행중인 큐의 꼬리에서 작업을 훔쳐서 가져오는것.

7.3 Spliterator
	자바 8 에서는 Spliterator 새로운 인터페이스를 제공한다. Spliterator 는 '분할 할 수 있는 반복자' 라는 의미다.
	Iterator 처럼 Spliterator 는 소스의 요소 탐색 기능을 제공한다는 점은 같지만, 병렬에 특화되어 잇다.

	Spliterator 인터페이스
	public interface Spliterator<T> {
		boolean tryAdvance(Consumer<? super T> action);
		Spliterator<T> trySplit();
		long estimateSize();
		int characteristics();
	}

	여기서 T 는 Spliterator 에서 탐색하는 요소의 형식을 가리킨다.
	tryAdvance 메서드는 Spliterator 의 요소를 하나씩 순차적으로 소비하면서 탐색해야 할 요소가 남아있으면 참을 반환한다.
	즉, 일반적인 Iterator 와 같다.

	반면 trySplit 메서드는 Spliterator 의 일부 요소(자신이 반환한 요소)를 분할해서 탐색해야 할 요소 수 정보를 제공할 수 있다.

7.3.1 분할 과정
스트림으로 분할하는 과정은 재귀적으로 일어난다.
첫번째 Spliterator 에서 trySplit 을 호출하면 2번째 Spliterator 가 생성된다.
2단계 에서 두개의 Spliterator 에 trySplit 을 호출하면 4개의 Spliterator 가 생성된다.

7.3.2 커스텀 Spliterator 구현하기.
Spliterator 를 구현하는 예제를 살펴보자. 문자열의 단어수를 계산하는 단순한 메서드를 구현할 것이다.(word count)

예제 7-4 반복형 단어 개수 메서드
	public int contWordsIteratively(String s) {
		int counter = 0;
		boolean lastSpace = true;

		for (char c : s.toCharArray()) {
			if (Character.isWhitespace(c)) {
				lastSpace = true;
			} else {
				if (lastSpace) {
					count++;
				}
				lastSpace = false
			}
		}
		return counter;
	}


함수형으로 단어 개수 계산 메서드 재구현하기.
 우선 String 을 스트림으로 변환해야 한다. 안타깝게도 스트림은 int, long, double 기본형만 제공하므로
 Stream<Character> 를 사용해야 한다.

 Stream<Character> stream = IntStream.range(0, SENTENCE.length()).mapToObj(SENTENCE::charAt);

 스트림에 리듀싱 연산을 실행하면서 단어수를 계산할 수 있다.
이때 지금까지 발견한 단어수를 계산하는 int 변수와 마지막 문자가 공백이었는지 여부를 기억하는 boolean 변수 등 두가지 변수가 필요하다.
하지만 Java 에는 튜플 객체가 없으므로 WordCounter 를 만들어야 한다.

class WordCounter {
	@Getter
	private final int counter;
	private final boolean lastSpace;

	public WordCounter(int counter, boolean lastSpace) {
		this.counter = counter;
		this.lastSpace = lastSpace;
	}

	public WordCounter accumlate(Character c) {
		if (Character.isWhitespace(c)) {
			return lastSpace ?
					this :
					new WordCounter(counter, true);
		} else {
			return lastSpace ?
					new WordCounter(counter + 1, false) :
					this;
		}
	}

	public WordCounter combine(WordCounter wordCounter) {
		return new WordCounter(counter + wordCounter.counter, wordCounter.lastSpace);
	}
}
	
	
accumlate 메서드는  WordCounter 의 상태를 어떻게 바꿀것인지, 또는 엄밀히 WordCounter 는 불변 클래스 이므로 새로운 WordCounter 클래스를 어떤 상태로 생성할 것인지 정의한다.
스트림을 탐색하면서 새로운 문자를 찾을 때 마다 accumlate 메서드를 호출한다.

이제 다음코드처럼 문자 스트림의 리듀싱 연산을 직관적으로 구현할 수 있다.

private int countWords(Stream<Character> stream) {
	WordCounter wordCounter = stream.reduce(new WordCounter(0, true),
											WordCounter::accumlate,
											WordCounter::combine);

	return wordCounter.getCounter();
}

Stream<Character> stream = IntStream.range(0, SENTENCE.length())
									.mapToObj(SENTENCE::charAt);

System.out.println("Found" + countWords(stream) + " words"); // Found 19 words


하지만 wordCounter 를 구현했던 원래 이유는 병렬 수해이었음을 잊으면 안된다. 이번에는 이 동작을 어떻게 병렬로 수행할 수 있는지 살펴보자.

WordCounter 병렬로 수행하기
다음처럼 단어수를 계산하는 연산을 병렬스트림으로 처리하자.

System.out.println("Found" + countWords(stream.parallel()) + " words");  // Found 25 words

안타깝게도 원하는 결과는 나오지 않는다. 

원래 문자열을 임의의 위치에서 둘로 나누다 보니 예상치 못하게 하나의 단어를 둘로 계산하는 상황이 발생할 수 있다.
이 문제를 해결하기 위해서는 Spliterator 가 필요하다.

class WordCounterSpliterator implements Spliterator<Character> {
	private final String string;
	private int currentChar = 0;

	public WordCounterSpliterator(String string) {
		this.string = string;
	}

	@Override
	public boolean tryAdvance(Consumer<? super Character> action) {
		action.accept(String.charAt(currentChar++));
		return currentChar < string.length();
	} 

	@Override
	public Spliterator<Character> trySplit() {
		int currentSize = string.length() - currentChar;
		if (currentChar < 10) {
			return null;
		}
	}

	for (int splitPos = currentSize / 2 + currentChar; splitPos < string.length(); splitPos++) {
		if (Character.isWhitespace(string.charAt(splitPos))) {
			Spliterator<Character> Spliterator = 
					new WordCounterSpliterator(string.subString(currentChar, splitPos));
					currentChar = splitPos;
					return Spliterator;
			}
		}
		return null;
	}
	
	@Override
	public long estimateSize() {
		return string.length() - currentChar;
	}

	@Override
	public int characteristics() {
		return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;
	}
}



List -> Map 만들기 예제

personalDefaultCategories.stream().collect(Collectors.toMap(BestCategoryType::getCode, BestCategoryType::getAdzMetaCode));

