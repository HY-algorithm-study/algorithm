# 코틀린 기초

##2.1 기본 요소: 함수와 변수  


#### 2장에서 다루는 내용 :
- 함수, 변수, 클래스, enum, 프로퍼티 선언하는 방법
- 제어 구조
- 스마트 캐스트
- 예와 throw & chtch

### 2.1 기본 요소: 함수와 변수
#### 2.1.1 Hello World!
```kotlin
fun main (args: Array<String>) {
    println("Hello, World!")
}
```
 - 함수를 선언할 때 fun 키워드를 사용했다.   
 (실제로 코틀린에서 함수를 만드는 일은 fun 재미잇는 일이다..하하핫)
 - 파라미터 이름 뒤에 그 파라미터 타입을 쓴다. 
 - 함수를 최상위 수준에 정의 가능, 꼭 클래스 안에 함수를 넣어야 할 필요 X
 - 배열도 일반적인 클래스와 마찬가지다. 코틀린에서는 자바와 달리 배열을 처리하는 문법이 따로 존재하지 않는다.
 - System.out.println 대신 println 도 그런 함수다. 간단하게 감싼 wrapper 함수
 - 끝에 ; 없음
 
 
#### 2.1.2 함수

```kotlin
fun max(a: Int, b: Int) : Int {
    return if (a > b) a else b
}
```

코틀린에서 if 는 문이 아니라 식이다 . 
반면에 대입문은 자바에서는 식이었으나, 코틀린에서는 문이 됐다 **이점은 주의해야함**

#### 2.1.3 변수

자바는 변수를 선언할때 타입이 맨 앞에 온다. 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.

val question = "삶, 우주, 그리고 모든것에 대한 궁극적인 질문"
val answer = 42  
이 예제에서는 타입 표기를 생략했지만 원한다면 타입을 명시해도 된다.  
val answer : Int = 42   
초기화 식을 상요하지 않고 변수를 선언하려면 변수타입을 반드시 명시해야 한다.

**변경 가능한 변수와 변경 불가능한 변수**


- val(value) : 변경 불가능한
- var(variable) : 변경 가능한

기본적으로 모든 변수는 val 로 선언하고 나중에 꼭 필요할때만 var 로 선언을 해라.  

**tip**
```text
val 변수는 블록을 실행할때 오직 한번만 초기화가 됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 을 초기화 할 수 있다.


val message : String

if (check()) {
    message = "SUCCESS"
} else {
    message = "FAILED"
}
```

**주의**  

```text
val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있음을 기억해야함.

val languages = arrayListOf("java")     <- 불변 참조를 선언
languages.add("Kotlin")                 <- 참조가 가리키는 객체의 내부를 변경.

```

#### 2.1.4 더 쉽게 문자열 형식 지정 : 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "kotlin"
    println("Hello, $name!")
}
```
문자열에 $ 을 넣고 싶으면 '\' 와 함꼐 사용 해야 한다.

사실 $name 보다는 ${name} 과 같이 중괄호로 감사는게 좋은 습관이다.

### 2.2 클래스와 프로퍼티
이번절은 클래스를 선언하는 기본 문법을 소개하고 좀 더 자세한것은 4장에서 소개한다.

```java
public class Person {
    
    private  final String name;
    
    public Person(String name) {
        this.name = name;        
    }
    
    public String getName() {
        return name;
    }
}
```

자바에서는 이렇게 불필요한 코드가 늘어지게 된다. 이것은 자동 코틀린 번역기를 돌리면

```kotlin
class Person(val name: String)
```
한줄로 끝나게 된다. 이런유형의 클래스를 값 객체 (value object) 라고 한다.  
코틀린의 기본 가시성은 public 이므로 생략해도 된다.

#### 2.2.1 프로퍼티

클래스 내에서 변경 가능한 프로퍼티 선언하기.

```kotlin
class Person (
    val name : String,
    var isMarried : Boolean
)

```

name 은 변경 불가능이므로 getter 만 자동생성되어지고
isMarried 는 변경가능 변수이므로 getter, setter 가 같이 자동 생성 되어진다.

Person 클래스 사용하기.
```kotlin
val person = Person("Bob", true) // new 를 사용하지 않는다.
println(person.name) // 코틀린에서는 이름을 직접 사용해도 자동으로 게터를 호출해줌

// 마찬가지로 setter 도 
person.isMarried = false // 이라고 작성해도 자동으로 세터가 호출되어진다.
```

####2.2.2 커스텀 접근자.   
이번절에서는 프로퍼티의 접근자를 직접 작성하는 방법을 보여준다.  
직사각형 클래스인 Retangle 을 정의하면서 자신이 정사각형인지 알려주는 기능을 만들어보자.  
별도의 정사각형인지, 직사각형인지 필드는 필요없다. 사각형의 너비와 높이가 같은지 검사하면 그때그때 알 수 있다.

```kotlin
class Rectangle(val height: Int, val width : Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }
}
```
####2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지
보통 자바와 같이 import 하는 방식을 사용을 하고, 
함수이름을 import 할 수도 있따.

코틀린의 방식대로 디렉터리 구조를 정의할 수도 있지만, 보통은 자바에서의 디렉터리 구조를 따르는게 낫다.

###2.3 선택표현과 처리 : enum & when
이번절에서는 코틀린의 구성 요소중 when 에 대해서 설명한다.  
when 은 자바의 switch 를 대치하되 훨씬 더 강력하며 앞으로 더 자주 사용할 프로그래밍 요소라고 생각할 수 있다.

####2.3.1 enum 클래스 정의

```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```

enum 은 자바 선언보다 코틀린 선언에 더 많은 키워드를 써야하는 흔치않은 예다.
자바와 마찬가지로 enum 은 값만 열거하는 존재가 아니다.

enum 클래스 안에서도 프로퍼티나 메소드를 정의 할 수 있다.

```kotlin
enum class Color (
    val r: Int, val g: Int, val b: Int
) {
    RED(255, 0, 0),
    ORANGE(255, 165, 0),
    YELLOW(255, 255, 0),
    GREEN(0, 255, 0); // 여기서는 반드시 세미콜론(;) 을 붙여야 한다.
    
    fun rgb() = (r * 255 + g) * 255 + b
}
```

