# 6장 코틀린 타입 시스템
# 7장 연산자 오버로딩과 기타 관례

## 6.1 널 가능성
## 6.2 코틀린의 원시타입
### 6.2.5 Unit 타입: 코틀린의 void

```kotlin
fun f() : Unit {
    // ...
}

fun f() {
    // ...
}
```
void 와 unit 의 차이점은 unit 은 타입인자로 사용할 수 있다는 것이다.  
Unit 타입의 함수는 Unit 값을 묵시적으로 반환한다. 
이 두 특성은 제네릭 파라미터를 반환하는 함수를 오버라이드 하면서 반환 타입으로 Unit 을 쓸때 유용하다.

```kotlin
interface Processor<T> {
    fun process () : T
}

class NoResultProcessor : Processor<Unit> {
    override fun process() {
        // 업무 처리 코드
    }   
}
```

### 6.2.6 Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다.  
코틀린에서는 결코 성공적으로 값을 돌려주는 일이 없는, '반환값(return)' 이라는 개념 자체가 의미 없는 함수가 일부 존재 한다.  
예를 들어 테스트 라이브러리에서 fail 이라는 함수를 제공하는 경우 특정 에러만 던지고, 리턴을 하지 않을것이다.
다른 예로는 무한 루프를 도는 함수도 결코 값을 반환하며 정상적으로 끝나지 않는다.  

그런 의미들을 표현하기 위해 코틀린에는 Nothing 이라는 특별한 반환타입이 있다.

```kotlin
fun fail(message: String) : Nothing {
    throw IllegalStateException(message)
}
```

```
>>> fail("Error occurred")
java.lang.IllegalStateException: Error occurred
```


## 6.3 컬렉션과 배열
### 6.3.2 읽기 전용과 변경 가능한 컬렉션
컬렉션의 데이터를 수정하려면
MutableCollection 을 사용하라.
일반적인  Collection 을 확장하면서 추가, 삭제, 등 다양한 메서드를 더 제공한다.

-----------
chapter2. 코틀린답게 사용하기
----------- 
#7. 연산자 오버로딩과 기타 관례 
```
- 연산자 오버로딩
- 관례 : 여러 연산을 지원하기 위해 특별한 이름이 붙은 메소드
- 위임 프로퍼티
```

## 7.1 산술 연산자 오버라이딩
BigInteger 클래스를 다룬다면 add 메소드 보다는 + 연산을 사용하는 편이 더 낫다. 
여기서는 Point 라는 클래스로 예를 들어보자.

[7.1 plus 연산자 구현하기]

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus (other: Point) : Point {
        return Point(x + other.x, y + other.y)
    }
}
```

```
>>> val p1 = Point(10,20)
>>> val p2 = Point(30,40)
>>> println(p1 + p2) 
Point(x = 40, y = 60)
```

plus 함수 앞에 operator 키워드를 붙여야 한다. 
operator 를 붙임으로써 어떤 함수가 관례를 따르는 함수임을 명확히 알 수 있다.

[7.2 연산자를 확장 함수로 정의하기]

```kotlin
operator fun Point.plus(other: Point) : Point {
    return Potin(x + other.x, y + other.y)
}
```

[표 7.1 오버로딩 가능한 이항 산술 연산자]  

식       | 함수 이름         |  
------      |---------         |
|a * b     |times    |
|a / b   |div     |
|a % b  |mod (1.1 부터 rem)    |
|a + b    |plus    |
|a - b    |munus    |

### 7.1.2 복합 대입 연산자 오버로딩 
+=, -= 같은것도 재정의가 가능하다
plsuAssign, minusAssign 등으로 그러나 두개를 모두 정의하지는 말아라. 
이유는 알아서 찾아보길~~

### 7.1.3 단한 연산자 오버로딩
++, -- 같은것도 오버로딩 가능

## 7.2 비교 연산자 오버로딩
### 7.2.1 동등성 연산자 : equals
### 7.2.2 순서 연산자 : compareTo

## 7.3 컬렉션 범위에 대해 쓸수 있는 관례
### 7.3.1 인덱스로 원소에 접근 : get & set
get 관례 구현하기

```kotlin
operator fun Point.get(index: Int) : Int {
    return when (index) {
        0 -> x
        1 -> y
        else ->
        throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}
```

```
>>> val p = Point(10,20)
>>> println(p[1])
20
```

